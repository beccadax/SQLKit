//
//  SQLError.swift
//  LittlinkRouterPerfect
//
//  Created by Becca Royal-Gordon on 10/27/16.
//
//

import Foundation

/// Errors generated by SQLKit.
public enum SQLError: Error {
    static func makeExecutionFailed(with statement: SQLStatement) -> (Error) -> SQLError {
        return { .executionFailed(underlying: $0, statement: statement) }
    }
    
    static func makeColumnInvalid(with statement: SQLStatement, for key: ColumnSpecifier) -> (Error) -> SQLError {
        return { .columnInvalid(underlying: $0, key: key, statement: statement) }
    }
    
    static func makeValueInvalid(with statement: SQLStatement, for key: AnySQLColumnKey) -> (Error) -> SQLError {
        return { .valueInvalid(underlying: $0, key: key, statement: statement) }
    }
    
    /// The name or index of a column that did not actually exist.
    public enum ColumnSpecifier: Hashable, CustomStringConvertible {
        case name(String)
        case index(Int)
        
        public static func == (lhs: ColumnSpecifier, rhs: ColumnSpecifier) -> Bool {
            switch (lhs, rhs) {
            case let (.name(l), .name(r)) where l == r:
                return true
            case let (.index(l), .index(r)) where l == r:
                return true
            default:
                return false
            }
        }
        
        public var hashValue: Int {
            switch self {
            case .name(let name):
                return name.hashValue
            case .index (let index):
                return ~index.hashValue
            }
        }
        
        public var description: String {
            switch self {
            case .name(let name):
                return "\"\(name)\""
                
            case .index(let index):
                return String(describing: index)
            }
        }
    }
    
    /// The attempt to connect to the server failed. Thrown by 
    /// `SQLDatabase.makeConnection()`.
    case connectionFailed(underlying: Error)
    
    /// Executing or querying a statement failed. Thrown by `SQLConnection.execute`
    /// and `SQLConnection.query`.
    case executionFailed(underlying: Error, statement: SQLStatement)
    
    /// The query succeeded, but did not find any records. Thrown by 
    /// `SQLQuery.only()`.
    case noRecordsFound(statement: SQLStatement)
    
    /// The query succeeded, but found more than one record. Thrown by 
    /// `SQLQuery.only()`.
    case extraRecordsFound(statement: SQLStatement)
    
    /// The specified column was not found. Thrown by `SQLQuery.columnKey`.
    case columnInvalid(underlying: Error, key: ColumnSpecifier, statement: SQLStatement)
    
    /// The value in the column did not match the type required by the key. The 
    /// `underlying` error, which may or may not be a `SQLValueError`, explains 
    /// the reason.
    /// 
    /// May be thrown by `SQLRow.value(for:)` or the `SQLQuery.columnKey` methods.
    case valueInvalid(underlying: Error, key: AnySQLColumnKey, statement: SQLStatement)
}

/// Errors which describe common reasons a `SQLError.columnInvalid` may be thrown.
public enum SQLColumnError: Error {
    /// No column by that name or at that index was selected into the result.
    case columnMissing
    
    /// The column's values, which belong to the `from` type, cannot be converted 
    /// to the `to` type.
    case columnNotConvertible(to: SQLValue.Type, from: String?)
}

/// Errors which describe common reasons a `SQLError.valueInvalid` may be thrown.
public enum SQLValueError: Error {
    /// The value was `NULL`, but it was accessed using a non-nullable `SQLColumnKey`.
    case valueNull
    
    /// The value could not be converted to the type the column key indicates it 
    /// ought to be.
    /// 
    /// This should be thrown by `SQLStringConvertible.init(sqlLiteral:)` when there 
    /// is no more specific error that can be communicated.
    case stringNotConvertible(sqlLiteral: String, type: SQLStringConvertible.Type)
    
    /// Indicates that the `valueType` type indicated is not supported by `client`.
    /// See `SQLValue` for more information on why this might happen and what 
    /// `SQLValue` conformance means.
    case typeUnsupportedByClient(valueType: SQLValue.Type, client: _SQLClient.Type)
}

extension SQLError {
    public var statement: SQLStatement? {
        switch self {
        case .executionFailed(_, let statement), .noRecordsFound(let statement), .extraRecordsFound(let statement), .columnInvalid(_, _, let statement), .valueInvalid(_, _, let statement):
            return statement
            
        default:
            return nil
        }
    }
    
    public var columnKey: AnySQLColumnKey? {
        switch self {
        case .valueInvalid(_, let key, _):
            return key
            
        default:
            return nil
        }
    }
    
    public var underlying: Error? {
        switch self {
        case .connectionFailed(let underlying), .executionFailed(let underlying, _), .columnInvalid(let underlying, _, _), .valueInvalid(let underlying, _, _):
            return underlying
            
        default:
            return nil
        }
    }
}

extension SQLError: CustomNSError {
    public static var statementKey = "SQLKit.SQLError.statement"
    public static var columnKey = "SQLKit.SQLError.columnKey"
    
    public var userInfo: [String: Any] {
        var userInfo: [String: Any] = [:]
        
        if let statement = self.statement {
            userInfo[SQLError.statementKey] = String(describing: statement)
        }
        
        if let columnKey = self.columnKey {
            userInfo[SQLError.columnKey] = String(describing: columnKey)
        }
        else if case let .columnInvalid(underlying: _, key: spec, statement: _) = self {
            userInfo[SQLError.columnKey] = String(describing: spec)
        }
        
        if let underlying = self.underlying {
            userInfo[NSUnderlyingErrorKey] = underlying
        }
        
        return userInfo
    }
}

func withErrorsPackaged<R>(in makeError: (Error) -> Error, do body: () throws -> R) rethrows -> R {
    do {
        return try body()
    }
    catch let error as SQLError {
        // Permit SQLError through unmolested
        throw error
    }
    catch {
        /// Repackage everything else
        throw makeError(error)
    }
}
