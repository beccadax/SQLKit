//
//  SQLError.swift
//  LittlinkRouterPerfect
//
//  Created by Brent Royal-Gordon on 10/27/16.
//
//

import Foundation

/// Errors generated by SQLKit.
public enum SQLError: Error {
    /// The name or index of a column that did not actually exist.
    public enum ColumnSpecifier: Hashable, CustomStringConvertible {
        case name(String)
        case index(Int)
        
        public static func == (lhs: ColumnSpecifier, rhs: ColumnSpecifier) -> Bool {
            switch (lhs, rhs) {
            case let (.name(l), .name(r)) where l == r:
                return true
            case let (.index(l), .index(r)) where l == r:
                return true
            default:
                return false
            }
        }
        
        public var hashValue: Int {
            switch self {
            case .name(let name):
                return name.hashValue
            case .index (let index):
                return ~index.hashValue
            }
        }
        
        public var description: String {
            switch self {
            case .name(let name):
                return "\"\(name)\""
                
            case .index(let index):
                return String(describing: index)
            }
        }
    }
    
    /// The attempt to connect to the server failed. Thrown by 
    /// `SQLDatabase.makeConnection()`.
    case connectionFailed(message: String, underlying: Error?)
    
    /// Executing or querying a statement failed. Thrown by `SQLConnection.execute`
    /// and `SQLConnection.query`.
    case executionFailed(message: String, statement: SQLStatement, underlying: Error?)
    
    /// The query succeeded, but did not find any records. Thrown by 
    /// `SQLQuery.only()`.
    case noRecordsFound(statement: SQLStatement)
    
    /// The query succeeded, but found more than one record. Thrown by 
    /// `SQLQuery.only()`.
    case extraRecordsFound(statement: SQLStatement)
    
    /// The specified column was not found. Thrown by `SQLQuery.columnKey`.
    case columnMissing(ColumnSpecifier, statement: SQLStatement)
    
    /// The column was null, but the column key doesn't allow that. Thrown by 
    /// `SQLRow.value(for:)`.
    case columnNull(AnySQLColumnKey, statement: SQLStatement)
    
    /// The column was of a type that didn't match the column key, or attempting 
    /// to convert the specific value failed. May be thrown by `SQLRow.value(for:)` 
    /// or potentially by `SQLQuery.columnKey`.
    case columnNotConvertible(AnySQLColumnKey, sqlLiteral: String, statement: SQLStatement, underlying: Error?)
}

extension SQLError {
    public var statement: SQLStatement? {
        switch self {
        case .executionFailed(_, let statement, _), .noRecordsFound(let statement), .extraRecordsFound(let statement), .columnMissing(_, let statement), .columnNull(_, let statement), .columnNotConvertible(_, _, let statement, _):
            return statement
            
        default:
            return nil
        }
    }
    
    public var columnKey: AnySQLColumnKey? {
        switch self {
        case .columnNull(let key, _), .columnNotConvertible(let key, _, _, _):
            return key
            
        default:
            return nil
        }
    }
    
    public var underlying: Error? {
        switch self {
        case .connectionFailed(_, let underlying), .executionFailed(_, let underlying), .columnNotConvertible(_, _, _, let underlying):
            return underlying
            
        default:
            return nil
        }
    }
}

extension SQLError: CustomNSError {
    public static var statementKey = "SQLKit.SQLError.statement"
    public static var columnKey = "SQLKit.SQLError.columnKey"
    
    public var userInfo: [String: Any] {
        var userInfo: [String: Any] = [:]
        
        if let statement = self.statement {
            userInfo[SQLError.statementKey] = String(describing: statement)
        }
        
        if let columnKey = self.columnKey {
            userInfo[SQLError.columnKey] = String(describing: columnKey)
        }
        else if case let .columnMissing(spec, _) = self {
            userInfo[SQLError.columnKey] = String(describing: spec)
        }
        
        if let underlying = self.underlying {
            userInfo[NSUnderlyingErrorKey] = underlying
        }
        
        return userInfo
    }
}
